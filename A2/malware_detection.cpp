#include <iostream>
#include <vector>
#include <string>
#include <unistd.h>
#include <sys/wait.h>
#include <cstring>
#include <chrono>
#include <thread>
#include <ctime>
#include <algorithm>
#include <string>
#include <fstream>
#include <sstream>
using namespace std;


pid_t get_parent(pid_t pid){
    std::ostringstream stat_path;
    stat_path << "/proc/" << pid << "/stat";
    std::ifstream stat_file(stat_path.str());
    if (!stat_file.is_open()) {
        perror("Failed to open stat file");
        return 1;
    }

    std::string line;
    std::getline(stat_file, line);
    stat_file.close();

    std::istringstream line_stream(line);
    std::string dummy;
    int ppid;
    for (int i = 0; i < 3; ++i) {
        line_stream >> dummy;
    }
    line_stream >> ppid;
    return ppid;
}
double get_cpu_usage(pid_t pid)
{
    std::string stat_file = "/proc/" + std::to_string(pid) + "/stat";
    std::string stat_contents;
    std::ifstream stream(stat_file);
    std::getline(stream, stat_contents);
    stream.close();

    // Split the contents of the stat file by spaces
    std::vector<std::string> values;
    std::stringstream stat_stream(stat_contents);
    std::string buffer;
    while (stat_stream >> buffer)
    {
        values.push_back(buffer);
    }

    // Get the values of utime and stime
    long utime = std::stol(values[13]);
    long stime = std::stol(values[14]);
    long starttime = std::stol(values[21]);

    // Get the system uptime
    std::string uptime_file = "/proc/uptime";
    std::string uptime_contents;
    stream = std::ifstream(uptime_file);
    std::getline(stream, uptime_contents);
    stream.close();

    // Split the contents of the uptime file by spaces
    values.clear();
    std::stringstream uptime_stream(uptime_contents);
    while (uptime_stream >> buffer)
    {
        values.push_back(buffer);
    }

    // Get the value of uptime
    long uptime = std::stol(values[0]);

    // Calculate the total time the process has spent in user mode and kernel mode
    long total_time = utime + stime;

    // Calculate the seconds since the process started
    double seconds_since_start = uptime - (starttime / sysconf(_SC_CLK_TCK));

    // Calculate the current CPU usage of the process
    return ((total_time / sysconf(_SC_CLK_TCK)) / seconds_since_start) * 100;
}
// double get_cpu_usage(pid_t pid) {
//   string stat_file = "/proc/" + to_string(pid) + "/stat";
//   ifstream stat_stream(stat_file);
//   if (!stat_stream.is_open()) {
//     cerr << "Failed to open " << stat_file << endl;
//     return -1;
//   }

//   // Read the stat file and extract the relevant information
//   int utime, stime, cutime, cstime;
//   stat_stream >> utime >> stime >> cutime >> cstime;
//   stat_stream.close();

//   // Calculate the total CPU time used by the process
//   int total_time = utime + stime + cutime + cstime;

//   // Sleep for a short period of time
//   this_thread::sleep_for(chrono::milliseconds(100));

//   // Read the stat file again
//   stat_stream.open(stat_file);
//   if (!stat_stream.is_open()) {
//     cerr << "Failed to open " << stat_file << endl;
//     return -1;
//   }

//   // Read the stat file and extract the relevant information
//   stat_stream >> utime >> stime >> cutime >> cstime;
//   stat_stream.close();

//   // Calculate the total CPU time used by the process after the sleep period
//   int new_total_time = utime + stime + cutime + cstime;

//   // Calculate the CPU usage as a percentage of total CPU time
//   return (double)(new_total_time - total_time) / sysconf(_SC_CLK_TCK) / 0.1;
// }


pid_t detect_malware(vector<pid_t> pids){
    // if(get_cpu_usage(pids[0]) < 0.8){
    //     return 0;
    // }
    int size = pids.size();
    for(int i = 0; i < size; i++){
        if(get_cpu_usage(pids[i]) < 0.001){
            return pids[i];
        }
    }
    return 0;
}
vector<pid_t> get_parents(pid_t pid){
    vector<pid_t> parents;
    while(pid != 0){
        parents.push_back(pid);
        pid = get_parent(pid);
    }
    return parents;
}

int main(){
    cout << "Enter PID of suspicious process : " << endl;
    pid_t pid;
    cin >> pid;
    vector<pid_t> parents = get_parents(pid);
    
    pid_t malware_pid = detect_malware(parents);
    if(malware_pid != 0){
        cout << "Malware detected with pid : " << malware_pid << endl;
        cout << get_cpu_usage(malware_pid) << endl;
    }
    else{
        cout << "No malware detected" << endl;
    }
    return 0;
}